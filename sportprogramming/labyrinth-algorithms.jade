extends ../layouts/code_layout.jade

block content
	div.row: div.large-12.columns: h1 Алгоритмы на лабиринтах
	div.row: div.large-12.columns
		h2 Постановка задачи
		div.text-justify У лабиринта нет стен, но он окружен кустами по внешним краям. Если игрок зашел в куст, то он проиграл. Лабиринт представлен как матрица (список (list) списков): 1 - это куст и 0 - это дорожка. Размер лабиринта N на N клеток и внешние клетки всегда кусты. Игрок начинает в клетке (1, 1). Выход в клетке (N-2, N-2). Вам нужно найти маршрут через Лабиринт. Игрок может двигатся только в четырех направлениях -- Юг (вниз [1,0]), Север (вверх [-1,0]), Восток (вправо [0,1]), Запад (влево [0, -1]). Маршрут описывается строкой состоящей из следующих символов: "S"=Юг, "N"=Север, "E"=Восток, and "W"=Запад.
		div Пример:
		pre.python: code
			|maze = [
			|	[1, 1, 1, 1, 1],
			| 	[1, 0, 1, 0, 1],
			| 	[1, 0, 1, 0, 1],
			| 	[1, 0, 0, 0, 1],
			| 	[1, 1, 1, 1, 1]
			| ]
			|solve = "SSEE"
		div В общем виде в такого рода задачах лабиринт можно представить в виде графа. Где пустые клетки - это вершины, а ребрами соединены те клетки- вершины, которые прилегают друг к другу, т.е. те на которые можно пойти. Реализуем граф, как словарь. Координаты клеток будем представлять кортежем. В словаре ключами будут координаты клетки-вершины, а значениями будет список кортежей из координат соседних клеток и направлении по которым можно добраться до клетки-вершины. Например, для лабиринта выше. Возьмем клетку с координатами (1, 1). В эту клетку можно попасть только из клетки (2, 1) двигаясь на Юг. Должны получить: {(1, 1): [('S', (2, 1))]} Имеем, что каждая вершина имеет уникальное имя - это координаты клетки. А направление мы будет использовать для восстановления пути. Функция преобразования лабиринта в граф будет выглядеть:
		pre.python: code
			include ../python_source/maze2graph.py	
		
		pre.python: code
			|{(1, 1): [('S', (2, 1))],
			| (1, 3): [('S', (2, 3))],
			| (2, 1): [('N', (1, 1)), ('S', (3, 1))],
			| (2, 3): [('N', (1, 3)), ('S', (3, 3))],
			| (3, 1): [('E', (3, 2)), ('N', (2, 1))],
			| (3, 2): [('E', (3, 3)), ('W', (3, 1))],
			| (3, 3): [('W', (3, 2)), ('N', (2, 3))]}

		h2 Ссылки по теме
			ol
				li: a(href="http://habrahabr.ru/post/181265/") Необыкновенный способ генерации лабиринтов
				li: a(href="http://bryukh.com/labyrinth-algorithms/") Алгоритмы на лабиринтах