extends ../layouts/code_layout.jade

block content
	div.row: div.large-12.columns: h1 Алгоритмы на лабиринтах
	div.row: div.large-12.columns
		h2 Постановка задачи
		div.text-justify У лабиринта нет стен, но он окружен кустами по внешним краям. Если игрок зашел в куст, то он проиграл. Лабиринт представлен как матрица (список (list) списков): 1 - это куст и 0 - это дорожка. Размер лабиринта N на N клеток и внешние клетки всегда кусты. Игрок начинает в клетке (1, 1). Выход в клетке (N-2, N-2). Вам нужно найти маршрут через Лабиринт. Игрок может двигатся только в четырех направлениях:
			ul 
				li Юг(S) (вниз [1,0]);
				li Север(N) (вверх [-1,0]);
				li Восток(E) (вправо [0,1]); 
				li Запад(W) (влево [0, -1]). 
		div Маршрут описывается строкой состоящей из следующих символов: "S"=Юг, "N"=Север, "E"=Восток, and "W"=Запад.
		div Пример:
		pre.python: code
			|maze = [
			|	[1, 1, 1, 1, 1],
			| 	[1, 0, 1, 0, 1],
			| 	[1, 0, 1, 0, 1],
			| 	[1, 0, 0, 0, 1],
			| 	[1, 1, 1, 1, 1]
			| ]
			|solve = "SSEE"
		div В общем виде в такого рода задачах лабиринт можно представить в виде графа. Где пустые клетки - это вершины, а ребрами соединены те клетки- вершины, которые прилегают друг к другу, т.е. те на которые можно пойти. Реализуем граф, как словарь. Координаты клеток будем представлять кортежем. В словаре ключами будут координаты клетки-вершины, а значениями будет список кортежей из координат соседних клеток и направлении по которым можно добраться до клетки-вершины. Например, для лабиринта выше. Возьмем клетку с координатами (1, 1). В эту клетку можно попасть только из клетки (2, 1) двигаясь на Юг. Должны получить: {(1, 1): [('S', (2, 1))]} Имеем, что каждая вершина имеет уникальное имя - это координаты клетки. А направление мы будет использовать для восстановления пути. Функция преобразования лабиринта в граф будет выглядеть:
		pre.python: code
			include ../python_source/maze2graph.py	
		
		div Сначала мы создаем словарь с ключами, которые равны координатам наших свободных клеток.
		pre.python: code
			|height = len(maze)
			|width = len(maze[0]) if height else 0
			|graph = {(i, j): [] for j in range(width) for i in range(height) if not maze[i][j]}
		div Получаем словарь:
		pre.python: code
			|{(1, 1): [],
			|(1, 3): [],
			|(2, 1): [],
			|(2, 3): [],
			|(3, 1): [],
			|(3, 2): [],
			|(3, 3): []}
		div Далее приступаем к заполнению списков
		div Окончательный результат преобразования выглядит так:
		pre.python: code
			|{(1, 1): [('S', (2, 1))],
			| (1, 3): [('S', (2, 3))],
			| (2, 1): [('N', (1, 1)), ('S', (3, 1))],
			| (2, 3): [('N', (1, 3)), ('S', (3, 3))],
			| (3, 1): [('E', (3, 2)), ('N', (2, 1))],
			| (3, 2): [('E', (3, 3)), ('W', (3, 1))],
			| (3, 3): [('W', (3, 2)), ('N', (2, 3))]}

		div Полный пример кода.
		pre.python: code
			include ../python_source/maze2graph_example.py

		h2 Нахождение пути
		div.text-justify Следующая задача, которую нам нужно решить - это нахождение пути, что для лабиринта является выходом. Для это изучим ряд алгоритмов:
			ul
				li: a(href="#BFS") Поиск в ширину. Breadth-first searching (BFS)
				li: a(href="#DFS")  Поиск в глубину. Depth-first search (DFS)
				li: a(href="#AS")  Умный поиск. A* Search

		h3(id="BFS") Поиск в ширину. Breadth-first searching (BFS)
			
		div Полный пример кода.
		pre.python: code
			include ../python_source/bfs_maze_example.py

		h3(id="DFS")  Поиск в глубину. Depth-first search (DFS)

		div Полный пример кода.
		pre.python: code
			include ../python_source/dfs_maze_example.py
		h3(id="AS")  Умный поиск. A* Search

		div Полный пример кода.
		pre.python: code
			include ../python_source/aseach_maze_example.py

		h2 Ссылки по теме
		ol
			li: a(href="http://habrahabr.ru/post/181265/") Необыкновенный способ генерации лабиринтов
			li: a(href="http://bryukh.com/labyrinth-algorithms/") Алгоритмы на лабиринтах